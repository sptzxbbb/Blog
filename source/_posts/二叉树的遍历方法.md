---
title: 二叉树的遍历方法
tags: [Tree, Algorithm]
category: [DataStructure]
date: 2015-05-22
---

二叉树的遍历方法一般来说有四种，分别是先序遍历，中序遍历，后序遍历和按层遍历。

以一棵二叉树为例子：

![binary tree](/images/2015-05-22-二叉树的遍历方法/binary.png) 

<!--more-->

节点数据结构如下。

~~~c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
};
~~~


---

### 先序遍历 ###
根左右：先访问根节点，再访问左子树，最后访问右子树。

递归实现。

~~~c++
    void preorderTraversal(TreeNode* root) {
        if (root != NULL) {
            cout << root->val << ‘ ’;
            if (root->left != NULL) pre(root->left);
            if (root->right != NULL) pre(root->right);
        }
    }
~~~
栈实现：根节点先入栈，访问栈顶的根节点，再把右子树节点和左子树节点依次入栈(保证左节点在右节点上面)，重复访问栈顶节点直至空栈。

~~~c++
void preorderTraversal(TreeNode* root) {
    stack<TreeNode*> order;
    TreeNode* temp;
    if (root != NULL) order.push(root);
    while (!order.empty()) {
        temp = order.top();
        cout << temp->val << ' ';
        order.pop();
        if (temp->right != NULL)
        order.push(temp->right);
        if (temp->left != NULL)
        order.push(temp->left);
    }
}
~~~


---

### 中序遍历 ###
左根右：先访问左子树，再访问根节点，最后访问右子树。

递归实现。

~~~c++
    void inorderTraversal(TreeNode* root) {
        if (root != NULL) {
            if (root->left != NULL) in(root->left);
            cout << root->val << endl;
            if (root->right != NULL) in(root->right);
        }
    }
~~~
栈实现：不断的把栈顶节点的左子树节点入栈，直到左子树节点为空为止，然后访问栈顶节点(即根节点)，然后对根节点的右子树重复上述操作。

~~~c++
void inorderTraversal(TreeNode* root) {
    stack<TreeNode*> order;
    TreeNode* p = root;
    while (p != NULL || !order.empty()) {
        if (p != NULL) {
            order.push(p);
            p = p->left;
        } else {
            p = order.top();
            order.pop();
            cout << p->val << ' ';
            p = p->right;
        }
    }
}
~~~


---

### 后序遍历 ###
左右根：先访问左子树，再访问右子树，最后访问根节点。

递归实现。

~~~c++
    void post(TreeNode* root) {
        if (root != NULL) {
            if (root->left != NULL) post(root->left);
            if (root->right != NULL) post(root->right);
            cout << root->val << endl;
        }
    }
~~~
栈实现：根节点至少需要访问2次，容易想到的方法是对根节点进行标识，但步骤比较繁琐。反向思考较为简单，后序遍历的逆序是根右左，根右左的遍历顺序由先序遍历类比易得，再对其求逆即可得到后序遍历。整个过程用到两个栈，s和s2。

~~~c++
void postorderTraversal(TreeNode* root) {
    stack<TreeNode*> s;
    stack<int> s2;
    while (root != NULL || !s.empty()) {
        if (root != NULL) {
            s2.push(root->val);
            s.push(root);
            root = root->right;
        } else {
            root = s.top();
            s.pop();
            root = root->left;
        }
    }
    while (!s2.empty()) {
        cout << s2.top() << ' ';
        s2.pop();
    }
}
~~~


---

### 按层遍历 ###

队列实现：用一个队列来维护访问的节点，每次访问节点时，将其左子树节点和右子树节点加入队列末尾(如果非空)。按层遍历的难点在于如何判断每一层最后一个节点。此处用`NULL`来标识层的结束，如果队列头部为`NULL`，说明当前层已经访问结束，在队列末尾加入`NULL`来表示下一层的末尾，如果还有下一层的话。

~~~c++
void storyTraversal(TreeNode* root) {
    list<TreeNode*> l;
    if (root != NULL) {
        l.push_back(root);
        l.push_back(NULL);
    }
    while (!l.empty()) {
        root = l.front();
        l.pop_front();
        if (root != NULL) {
            cout << root->val << ' ';
            if (root->left != NULL) l.push_back(root->left);
            if (root->right != NULL) l.push_back(root->right);
        } else {
            if (!l.empty()) {
                l.push_back(NULL);
            }
            cout << endl;
        }
    }
    cout << endl;
}
~~~


